# 数组

* 内存：是一段连续的存储空间
* 基本特点：支持随机访问
  * 访问速度快且灵活：只需要存储头部地址，头部地址加偏移量可以访问到数组内任意元素，时间复杂度为O(1)
  * 插入/删除元素/头部插入：为了保证连续地址，需要挪动后续元素，时间复杂度为O(n)
  * 尾部插入：不用移动任意元素，时间复杂度为O(1)

* 关键：索引与寻址

## 实战：

* 特征：操作数据且要保序
* 模型：过滤器
* 基本思路：
  * 访问每个元素
  * 判断要这个元素的条件
  * 放进结果集
* 进阶思路
  * 先保序 后补操作
  * 使用额外空间
  * 正序不行可以倒序

## 题目：

* [Leetcode26题：删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)
* [Leetcode283题：移动零](https://leetcode-cn.com/problems/move-zeroes/)
* [Leetcode88题：合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

## 变长数组

* 定义：用户创建时不用固定数组长度
* 如何设计数组：
  * 支持索引与随机访问
  * 初始申请空间
    * 记录已用（size）和容量（capacity）
    * 不够使用啧申请2倍空间，拷贝至新空间，释放旧空间
    * 空间利用率不到25%，则释放一半空间
  * 边界情况考虑：空间不够 or 空间剩余
  * 接口与方法
    * 新建
    * 取值
    * 赋值
    * 删除（末尾/头部）
    * 插入（末尾/头部）



# 链表

* 内存：非连续空间，单链表比数组花费空间多一倍，存储next的指针，双链表花费三倍空间，存储next和pre的指针
* 特点：
  * 头部为head，末尾为tail
  * 插入/删除十分高效，时间复杂度为O(1)
  * 查找只能从头部开始，时间复杂度为O(n)
* 保护节点：防止出现访问null的情况，也可记录入口地址

## 实战
* 邻值查找
  * 按数值排序，建立双链表
  * 建立节点数组
  * 倒序查看每个下标

* 关键点
  * 索引的灵活性
  * 不同数据结构建立映射关系
  * 倒序思考


## 题目
* [Leetcode206题：反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
* [Leetcode25题：K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

# 数组链表结合使用


# 注意事项

* 检查程序的边界：
  * 检查程序访问数组是否合法，是否有意义。
  * 链表检查边界，单链表存在head保护节点，双链表存在head和tail两个保护节点
* 画图要画全
* 有序集合使用平衡树去维护
